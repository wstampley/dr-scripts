=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#pick
=end

custom_require.call(%w[common common-arcana common-items common-money common-travel drinfomon equipmanager events spellmonitor])

class BetterPick

  def initialize
    arg_definitions = [
      [
        { name: 'debug', regex: /debug/, optional: true, description: ''},
        { name: 'refill', regex: /refill/, optional: true, description: 'Refills your lockpick ring.' },
        { name: 'source', regex: /(source=(\w+))/, optional: true, description: 'Container with boxes to pick.'}
      ]
    ]

    args = parse_args(arg_definitions, true)

    @settings = get_settings()
    @debug = args.debug || @settings.pick['debug'] || false

    if args.source
      @sources = [ args.source.split('=')[1] ]
    elsif @settings.pick['picking_box_sources']
      @sources = @settings.pick['picking_box_sources']
    elsif @settings.picking_box_source
      @sources = [ @settings.picking_box_source ]
    end

    if @sources.nil?
      DRC.message('No valid configuration was found for box source. Exiting.')
      exit
    end

    @stop_pick_on_mindlock = @settings.stop_pick_on_mindlock
    @loot_nouns = @settings.lootables
    @trash_nouns = get_data('items').trash_nouns
    @use_glance = DRStats.thief?

    @trash_empty_boxes = @settings.pick['trash_empty_boxes'] || false
    @worn_trashcan = @settings.worn_trashcan
    @worn_trashcan_verb = @settings.worn_trashcan_verb

    @dismantle_type = @settings.lockpick_dismantle

    picking_data = get_data('picking').picking
    @lockpick_costs = picking_data['lockpick_costs']

    @pick_identify_messages = picking_data['pick_messages_by_difficulty'];
    @pick_retry = picking_data['pick_retry']
    @pick_quick_threshold = @settings.pick['pick_quick_threshold'] || 2
    @pick_normal_threshold = @settings.pick['pick_normal_threshold'] || 4
    @pick_careful_threshold = @settings.pick['pick_careful_threshold'] || 7

    @disarm_identify_messages = picking_data['disarm_messages_by_difficulty']

    @disarm_succeeded = picking_data['disarm_succeeded']
    @trap_sprung = picking_data['trap_sprung']
    @disarm_retry = picking_data['disarm_retry']
    @disarm_identify_failed = picking_data['disarm_identify_failed']
    @disarm_quick_threshold = @settings.pick['disarm_quick_threshold'] || 0
    @disarm_normal_threshold = @settings.pick['disarm_normal_threshold'] || 2
    @disarm_careful_threshold = @settings.pick['disarm_careful_threshold'] || 5
    @disarm_too_hard_threshold = @settings.pick['disarm_too_hard_threshold'] || 10

    @all_trap_messages = picking_data['traps']
    @disarmed_trap_messages = picking_data['disarmed_traps']

    @harvest_traps = @settings.harvest_traps
    @component_container = @settings.component_container
    @trap_parts = picking_data['trap_parts']

    if @debug
      echo "better-pick-debug: Settings..."
      echo "- Sources: #{@sources}"
      echo "- harvest_traps: #{@harvest_traps}"
      echo "- component_container: #{@component_container}"
      echo "- stop_pick_on_mindlock: #{@stop_pick_on_mindlock}"
      echo "- loot_nouns: #{@loot_nouns}"
      echo "- trash_nouns: #{@trash_nouns}"
      echo "- disarm_quick: #{@disarm_quick_threshold}"
      echo "- disarm_normal: #{@disarm_normal_threshold}"
      echo "- disarm_careful: #{@disarm_careful_threshold}"
      echo "- disarm_too_hard: #{@disarm_too_hard_threshold}"
      echo "- pick_quick: #{@pick_quick_threshold}"
      echo "- pick_normal: #{@pick_normal_threshold}"
      echo "- pick_careful: #{@pick_careful_threshold}"
    end

    if args.refill
      refill_ring
    elsif stop_picking?
      echo 'Exiting due to mindstate...'
    else
      @equipment_manager = EquipmentManager.new
      setup_flags
      open_containers
      check_for_boxes
      remove_hindering_gear
      crack_boxes
      stop_buffs
      refill_ring
    end
  end

  def open_containers
    @sources.each do |source_container|
      DRCI.open_container?(source_container)
    end
    DRCI.open_container?(@settings.picking_box_storage) if @settings.picking_box_storage
    DRCI.open_container?(@settings.component_container) if @settings.component_container
  end

  def check_for_boxes
    @boxes_by_bag = {}
    @sources.each do |source_container|
      @boxes_by_bag[source_container] = DRC.get_boxes(source_container)
    end
    if @boxes_by_bag.values.flatten.empty?
      echo "No boxes to pop"
      exit
    end
  end

  def remove_hindering_gear
    @equipment_manager.empty_hands

    @removed_items = @equipment_manager.remove_gear_by(&:hinders_lockpicking)

    if DRC.left_hand || DRC.right_hand
      DRC.message('***ITEMS ARE STILL IN HANDS, EXITING***')
      @equipment_manager.wear_items(@removed_items)
      exit
    end
  end

  def setup_flags
    Flags.add('disarm-shift', 'something to shift')
    Flags.add('disarm-trap-type', *@all_trap_messages.values)
    Flags.add('more-traps', 'not fully disarmed', 'not yet fully disarmed', 'still has more to torment you with')
    Flags.add('more-locks', 'You discover another lock protecting')
    Flags.add('glance-no-traps', 'It looks like there are no traps left on')
    Flags.add('glance-no-locks', 'It looks like there are no locks left on')
  end

  def crack_boxes
    @boxes_by_bag.each do |source, boxes|
      boxes.each do |box_noun|
        break if stop_picking?

        do_buffs
        DRC.bput('sit', 'You sit', 'You are already sitting') unless sitting?
        DRCI.get_item?(box_noun, source)
        attempt_open(box_noun)
      end
      break if stop_picking?
    end

    DRC.fix_standing
    @equipment_manager.wear_items(@removed_items)
  end

  def stop_picking?
    @stop_pick_on_mindlock && DRSkill.getxp('Locksmithing') >= 30
  end

  def do_buffs
    if @settings.lockpick_buff_bot && DRRoom.pcs.include?(@settings.lockpick_buff_bot)
      DRC.bput("whisper #{@settings.lockpick_buff_bot} buff hol", "You whisper")
    end

    if @settings.waggle_sets['pick']
      DRC.wait_for_script_to_complete('buff', ['pick'])
    end
  end

  def stop_buffs
    drca_stop_buffs(@settings, 'pick') if DRStats.barbarian? || DRStats.thief?
  end

  # TODO - Move to DRCA
  def drca_stop_buffs(settings, set_name)
    return unless settings.waggle_sets[set_name]

    spells = settings.waggle_sets[set_name]

    if DRStats.barbarian?
      stop_barb_abilities
    elsif DRStats.thief?
      stop_khris(spells)
    else
      release_spells(spells)
    end
  end

  # TODO - Move to DRCA
  def stop_barb_abilities
    DRC.bput('meditate stop')
  end

  # TODO - Move to DRCA
  def stop_khris(spells)
    spells.each { |name| DRC.bput("khri stop #{name}", "You attempt to relax your mind from some of its meditative states") }
  end

  # TODO - Move to DRCA
  def release_spells(spells)
    spells.each { |spell| DRC.bput("release #{spell.abbrev}") }
  end

  def refill_ring
    return unless @settings.use_lockpick_ring
    return if @settings.skip_lockpick_ring_refill

    lockpicks_needed = DRCI.count_lockpick_container(@settings.lockpick_container)
    return if lockpicks_needed < 15

    cost = @lockpick_costs[@settings.lockpick_type]
    if cost.nil?
      DRC.message("***UNKNOWN LOCKPICK TYPE: #{@settings.lockpick_type}, UNABLE TO REFILL YOUR LOCKPICK RING***")
      return
    end

    DRCM.ensure_copper_on_hand(cost * lockpicks_needed, @settings)
    DRCT.refill_lockpick_container(@settings.lockpick_type, @settings.hometown, @settings.lockpick_container, lockpicks_needed)
  end

  def attempt_open(box_noun)
    echo "attempt_open(#{box_noun})" if @debug

    current_box = {
      'noun' => box_noun,
      'trap_difficulty' => nil,
      'trap' => nil,
      'trapped' => true,
      'lock_difficulty' => nil,
      'locked' => true
    }

    if @settings.use_skeleton_key
      try_unlock_box_with_key(current_box)
    end

    while holding_box?(current_box) && current_box['trapped'] || current_box['locked']

      while holding_box?(current_box) && current_box['trapped']
        while current_box['trap_difficulty'].nil?
          glance(current_box) if @use_glance
          identify_trap(current_box)
          check_danger
        end

        if current_box['trap_difficulty'] >= @disarm_too_hard_threshold
          echo 'identified box trap as too hard' if @debug
          handle_trap_too_hard(current_box)
          return
        end

        while current_box['trapped'] && !current_box['trap_difficulty'].nil?
          disarm_trap(current_box)
          check_danger
        end
      end

      # Make sure we still have the box in hand, cause sometimes failed disarms make that not true...
      while holding_box?(current_box) && !current_box['trapped'] && current_box['locked']
        find_lockpick unless @settings.use_lockpick_ring

        while current_box['lock_difficulty'].nil?
          glance(current_box) if @use_glance
          identify_lock(current_box)
          check_danger
        end

        while !current_box['trapped'] && current_box['locked'] && !current_box['lock_difficulty'].nil?
          pick(current_box)
          check_danger
        end
      end
    end

    return unless holding_box?(current_box)

    stow_hands_except(current_box['noun'])
    loot(current_box['noun'])
    dispose_empty_box(current_box)
  end

  def try_unlock_box_with_key(box)
    return false unless @settings.use_skeleton_key
    DRCI.get_item_if_not_held?(@settings.skeleton_key)
    result = bput("turn my #{@settings.skeleton_key} at my #{box}", "^You turn", "that doesn't seem to do much", "I could not find", "What were you referring")
    waitrt?
    key_worked = result =~ /^You turn/
    box['disarmed'] = !key_worked
    box['locked'] = !key_worked
  end

  def holding_box?(box)
    return DRCI.in_hands?(box['noun'])
  end

  def glance(box)
    Flags.reset('glance-no-traps')
    Flags.reset('glance-no-locks')

    DRC.bput("glance #{box['noun']}", "Looking more closely you see", "It looks like there are no locks")

    box['trapped'] = false if Flags['glance-no-traps']
    box['locked'] = false if Flags['glance-no-locks']
  end

  def identify_trap(box)
    echo "identify_trap(#{box})" if @debug

    Flags.reset('disarm-trap-type')

    disarm_identify_match = DRC.bput("disarm my #{box['noun']} identify", @disarm_identify_failed, @disarm_identify_messages, @disarmed_trap_messages.values)
    case disarm_identify_match
    when *@disarm_identify_failed
      echo "Failed to identify trap" if @debug
    when *@disarmed_trap_messages.values
      echo "Identified already disarmed trap: #{Flags['disarm-trap-type']} - #{disarm_identify_match}"
      box['trap'] = @disarmed_trap_messages.key("#{disarm_identify_match}")
      box['trapped'] = false
      box['trap_difficulty'] = 0
    else
      echo "Identified trap: #{Flags['disarm-trap-type']} - #{disarm_identify_match}" if @debug
      box['trap'] = @all_trap_messages.key("#{Flags['disarm-trap-type']}")
      box['trap_difficulty'] = @disarm_identify_messages.find_index(disarm_identify_match)
    end
  end

  def disarm_trap(box)
    echo "disarm_trap(#{box})" if @debug

    case box['trap_difficulty']
    when 0..(@disarm_quick_threshold-1)
      echo 'identified box trap as blind difficulty' if @debug
      speed = 'blind'
    when @disarm_quick_threshold..(@disarm_normal_threshold-1)
      echo 'identified box trap as quick difficulty' if @debug
      speed = 'quick'
    when @disarm_normal_threshold..(@disarm_careful_threshold-1)
      echo 'identified box trap as normal difficulty' if @debug
      speed = ''
    when @disarm_careful_threshold..Float::INFINITY
      echo 'identified box trap as careful difficulty' if @debug
      speed = 'careful'
    end

    Flags.reset('more-traps')
    Flags.reset('disarm-shift')
    trapped = true

    case DRC.bput("disarm my #{box['noun']} #{speed}", @trap_sprung, @disarm_retry, @disarm_succeeded)
    when *@trap_sprung
      DRC.message('**SPRUNG TRAP**')
      DRC.message('**SPRUNG TRAP**')
      trapped = false
    when *@disarm_retry
      trapped = true
    when *@disarm_succeeded
      trapped = false
    end

    box['trapped'] = trapped
    box['trap_difficulty'] += 1 if Flags['disarm-shift']

    if Flags['more-traps']
      echo "Saw another trap after disarming one..." if @debug
      box['trapped'] = true
      box['trap_difficulty'] = nil
    end
  end

  def handle_trap_too_hard(box)
    if @settings.picking_box_storage && DRC.right_hand
      echo "Putting away box cause it was not disarmed" if @debug
      unless DRCI.put_away_item?(box['noun'], @settings.picking_box_storage)
        echo "Throwing away box cause it was not disarmed and can't be stowed" if @debug
        DRCI.dispose_trash(box['noun'], @worn_trashcan, @worn_trashcan_verb)
      end
    elsif DRC.right_hand
      echo "Throwing away box cause it was not disarmed and picking_box_storage is not set" if @debug
      DRCI.dispose_trash(box['noun'], @worn_trashcan, @worn_trashcan_verb)
    end
  end

  def identify_lock(box)
    echo "identify_lock(#{box})" if @debug

    pick_identify_match = DRC.bput("pick my #{box['noun']} ident", @pick_identify_messages, @pick_retry, /Find a more appropriate tool and try again/, /It's not even locked, why bother/)
    case pick_identify_match
    when /Find a more appropriate tool and try again/, *@pick_retry
      box['locked'] = true
      box['lock_difficulty'] = nil
    when /It's not even locked, why bother/
      box['locked'] = false
      box['lock_difficulty'] = 0
    when *@pick_identify_messages
      echo "Identified lock: #{pick_identify_match}" if @debug
      box['lock_difficulty'] = @pick_identify_messages.find_index(pick_identify_match)
    end
  end

  def pick(box)
    case box['lock_difficulty']
    when 0..(@pick_quick_threshold-1)
      echo 'identified box lock as blind difficulty' if @debug
      speed = 'blind'
    when @pick_quick_threshold..(@pick_normal_threshold-1)
      echo 'identified box lock as quick difficulty' if @debug
      speed = 'quick'
    when @pick_normal_threshold..(@pick_careful_threshold-1)
      echo 'identified box lock as normal difficulty' if @debug
      speed = ''
    when @pick_careful_threshold..Float::INFINITY
      echo 'identified box lock as careful difficulty' if @debug
      speed = 'careful'
    end

    Flags.reset('more-locks')
    Flags.reset('more-traps')
    locked = true

    case DRC.bput("pick my #{box['noun']} #{speed}", @trap_sprung, 'not even locked',
                  'you remove your lockpick and open and remove the lock', 'You discover another lock protecting',
                  'You are unable to make any progress towards opening the lock', /Find a more appropriate tool and try again/,
                  'Pick what?')
    when 'Find a more appropriate tool and try again'
      @use_lockpick_ring = false
    when *@trap_sprung
      DRC.message('**SPRUNG TRAP**')
      DRC.message('**SPRUNG TRAP**')
    when 'you remove your lockpick and open and remove the lock', 'not even locked'
      locked = false
    when 'Pick what?'
      # Edge case, probably lost the box to a trap or messed with stuff manually.
      # Just mark the box unlocked so that it checks and continues
      DRC.message('You are missing a box, either due to manual intervention or trap failure.')
      locked = false
    end

    box['locked'] = locked

    if Flags['more-traps']
      box['trapped'] = true
      box['trap_difficulty'] = nil
    end
    if Flags['more-locks']
      box['lock_difficulty'] = nil
      box['locked'] = true
    end
  end

  # Put away lockpick or skeleton key, need both hands to loot and dismantle box.
  def stow_hands_except(item)
    DRCI.stow_hand('left') unless DRC.left_hand.nil? || DRCI.in_left_hand?(item)
    DRCI.stow_hand('right') unless DRC.right_hand.nil? || DRCI.in_right_hand?(item)
  end

  def dispose_empty_box(box)
    if @trash_empty_boxes
      DRCI.dispose_trash(box['noun'], @worn_trashcan, @worn_trashcan_verb)
    else
      dismantle(box)
    end
  end

  def dismantle(box)
    DRC.release_invisibility
    command = "dismantle my #{box['noun']} #{@dismantle_type}"
    case DRC.bput(command, 'repeat this request in the next 15 seconds', 'Roundtime', 'You must be holding the object you wish to dismantle', 'Your hands are too full for that', 'You can not dismantle that')
    when 'repeat this request in the next 15 seconds'
      dismantle(box)
    when 'Your hands are too full for that'
      stow_hands_except(box['noun'])
      dismantle(box)
    when 'You can not dismantle that'
      DRCI.dispose_trash(box['noun'], @worn_trashcan, @worn_trashcan_verb)
    end
  end

  def loot(box_noun)
    echo "Looting #{box_noun}..." if @debug
    if DRC.bput("open my #{box_noun}", /You open/, /^In the .* you see .*\./, 'That is already open', 'It is locked') == 'It is locked'
      echo 'Bug: Tried to loot locked box...'
      return
    end

    DRC.bput("fill my #{@settings.gem_pouch_adjective} pouch with my #{box_noun}", 'You fill your', 'You open your', 'What were you referring to', /any gems/, /too full to fit/)  if (@settings.fill_pouch_with_box || @settings.loot_specials.empty?)

    box_items = DRCI.get_item_list(box_noun, 'look');
    loot = box_items.map { |item| DRC.get_noun(item) }
    echo "box items: #{box_items} - loot: #{loot}" if @debug

    loot.each { |item| loot_item(item, box_noun) }
  end

  def loot_item(item, box)
    # We don't touch glowing fragments, since we took off all our armor...
    return if item =~ /fragment/i

    item_long = nil
    case DRC.bput("get #{item} from my #{box}", 'You get (.*) from inside', 'You pick up \d* \w* (?:lirum|dokora|kronar)s?')
    when /You pick up/ # Coins
      return
    when /You get (.*) from inside/
      item_long = Regexp.last_match(1)
      echo "Looted: #{item_long}" if @debug
    end

    if @settings.loot_specials.find { |x| /\b#{x['name']}\b/i =~ item_long }
      DRCI.put_away_item?(item, special['bag'])
    elsif @loot_nouns.find { |thing| item_long.include?(thing) && !item_long.include?('sunstone runestone') }
      case DRC.bput("stow my #{item}", 'You put', 'You open', 'You think the .* pouch is too full to fit', 'You\'d better tie it up before putting')
      when /You put/, /You open/ # Normal Case
        return
      when /You'd better tie it up/ # Gem + Full Untied Gem Pouch
        DRC.bput('tie my pouch', 'You tie')
        DRC.bput("stow #{item}", 'You pick')
      when /'You think the .* pouch is too full to fit/ # Gem + Full Gem Pouch
        DRC.bput("drop #{item}", 'You drop')
        return unless @settings.spare_gem_pouch_container
        swap_out_full_gempouch
        DRC.bput("stow #{item}", 'You pick')
      end
    elsif @trash_nouns.find { |thing| item_long =~ /\b#{thing}\b/i }
      DRCI.dispose_trash(item, @worn_trashcan, @worn_trashcan_verb)
    else
      DRC.message("***Unrecognized Item: #{item_long} - trashing it.***")
      DRCI.dispose_trash(item, @worn_trashcan, @worn_trashcan_verb)
    end
  end

  def swap_out_full_gempouch
    DRCI.remove_item?("#{@settings.gem_pouch_adjective} pouch")
    if @settings.full_pouch_container
      DRCI.put_away_item?("#{@settings.gem_pouch_adjective} pouch", @settings.full_pouch_container)
    else
      DRCI.stow_item?("#{@settings.gem_pouch_adjective} pouch")
    end
    DRCI.get_item?("#{@settings.gem_pouch_adjective} pouch", @settings.spare_gem_pouch_container)
    DRCI.wear_item?("#{@settings.gem_pouch_adjective} pouch")
  end

  def find_lockpick
    return if left_hand

    if DRCI.get_item?('lockpick')
      # If we had to find a loose lockpick then either
      # the player isn't using a lockpick ring or
      # the lockpick ring is now empty. Toggle setting
      # so that script will stow the left hand.
      @settings.use_lockpick_ring = false
    else
      DRC.message('***OUT OF LOCKPICKS***')
      DRCI.stow_hands
      exit
    end
  end

  def check_danger
    echo "check_danger: stunned?: #{stunned?} - bleeding?: #{bleeding?} - poisoned?: #{poisoned?}" if @debug
    pause 0.5 while stunned?
    return unless bleeding? || poisoned?

    snapshot = Room.current.id
    DRC.wait_for_script_to_complete('safe-room')
    DRCT.walk_to(snapshot)
  end

  def analyze(box)
    waitrt?
    case DRC.bput("disarm my #{box} analyze", /You've already analyzed/, /You are unable to determine a proper method/, 'Roundtime')
    when /You are unable to determine a proper method/
      return analyze(box)
    end
    harvest(box)
  end

  def harvest(box)
    case DRC.bput("disarm my #{box} harvest",
              /You fumble around with the trap apparatus/,
              /much for it to be successfully harvested/,
              /completely unsuitable for harvesting/,
              /previous trap have already been completely harvested/,
              'Roundtime')
    when /You fumble around with the trap apparatus/
      harvest(box)
    when 'Roundtime'
      waitrt?
      DRCI.put_away_item?(DRC.left_hand, @component_container) if @component_container && left_hand =~ @trap_parts
      DRCI.dispose_trash(DRC.left_hand, @worn_trashcan, @worn_trashcan_verb)
    end
  end
end

before_dying do
  Flags.delete('disarm-trap-type')
  Flags.delete('disarm-shift')
  Flags.delete('more-traps')
  Flags.delete('more-locks')
  Flags.delete('glance-no-traps')
  Flags.delete('glance-no-locks')

  EquipmentManager.new.wear_equipment_set?('standard')
end

BetterPick.new
